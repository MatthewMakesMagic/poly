# Story 3.3: Position Sizing & Liquidity

Status: review

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a **trader**,
I want **positions sized based on config and available liquidity**,
So that **I don't exceed risk limits or move the market (FR4, FR5)**.

## Acceptance Criteria

### AC1: Base Size from Strategy Config

**Given** an entry signal is generated
**When** calculating position size
**Then** base size comes from strategy config (FR35)
**And** size is expressed in dollar terms
**And** config validation rejects invalid size values at init time

### AC2: Liquidity-Aware Sizing

**Given** liquidity is thin
**When** orderbook depth is less than desired size
**Then** position size is reduced to available liquidity
**And** a warning is logged: "Size reduced due to liquidity"
**And** the trade proceeds with reduced size (not rejected)
**And** the log includes: requested_size, available_liquidity, actual_size

### AC3: Exposure Cap Enforcement

**Given** position would exceed exposure cap
**When** total exposure + new position > max exposure (FR5)
**Then** position size is reduced to fit within cap
**Or** the trade is rejected if minimum size not achievable
**And** rejection is logged with code='EXPOSURE_CAP_EXCEEDED'
**And** rejection includes: current_exposure, max_exposure, requested_size, available_headroom

### AC4: Maximum Position Size Limit

**Given** calculated size exceeds maximum position size limit (FR36)
**When** sizing is calculated
**Then** size is capped at maxPositionSize from config.risk
**And** a warning is logged if capped
**And** the trade proceeds with capped size

### AC5: Sizing Result Contract

**Given** sizing is calculated
**When** the result is returned
**Then** it includes: requested_size, actual_size, reason_for_adjustment
**And** this is logged for diagnostics
**And** reason is one of: 'no_adjustment', 'liquidity_limited', 'exposure_capped', 'position_limit_capped', 'rejected'

### AC6: Integration with Entry Signal Flow

**Given** entry signals are generated by strategy-evaluator
**When** orchestrator processes signals
**Then** each signal is passed to position-sizer for sizing
**And** sized positions are passed to order-manager for execution
**And** the full flow is logged with correlation IDs

### AC7: Minimum Size Threshold

**Given** a sizing calculation results in very small size
**When** actual_size < minimum tradeable size
**Then** the trade is rejected (not executed with tiny size)
**And** rejection is logged with reason='below_minimum_size'
**And** minimum size is configurable (default: $1)

## Tasks / Subtasks

- [x] **Task 1: Create Position-Sizer Module Structure** (AC: 5, 6)
  - [x] 1.1 Create `src/modules/position-sizer/` directory
  - [x] 1.2 Create `index.js` with standard module interface (init, getState, shutdown)
  - [x] 1.3 Create `types.js` with SizingResult, SizingError, and adjustment reasons
  - [x] 1.4 Create `state.js` for sizing statistics tracking
  - [x] 1.5 Create `sizing-logic.js` for core sizing calculations

- [x] **Task 2: Implement Base Sizing Logic** (AC: 1, 4)
  - [x] 2.1 Create calculateBaseSize(signal, config) function
  - [x] 2.2 Read base size from config.strategy.sizing.baseSizeDollars
  - [x] 2.3 Apply confidence multiplier (higher confidence = larger size, optional)
  - [x] 2.4 Cap at maxPositionSize from config.risk
  - [x] 2.5 Validate config values at init time

- [x] **Task 3: Implement Liquidity Analysis** (AC: 2)
  - [x] 3.1 Create analyzeOrderbookLiquidity(tokenId, side, desiredSize) function
  - [x] 3.2 Call polymarket.getOrderBook(tokenId) to get depth
  - [x] 3.3 Calculate available liquidity at acceptable slippage (e.g., 1%)
  - [x] 3.4 Return { availableLiquidity, estimatedSlippage, depthAtPrice }
  - [x] 3.5 Handle orderbook fetch errors gracefully

- [x] **Task 4: Implement Exposure Check** (AC: 3)
  - [x] 4.1 Create checkExposureLimits(currentExposure, newSize, maxExposure) function
  - [x] 4.2 Get current exposure from positionManager.getCurrentExposure()
  - [x] 4.3 Calculate headroom = maxExposure - currentExposure
  - [x] 4.4 Return adjusted size or rejection

- [x] **Task 5: Implement calculateSize() Main Function** (AC: 1, 2, 3, 4, 5, 7)
  - [x] 5.1 Create calculateSize(signal, options) that orchestrates all checks
  - [x] 5.2 Apply checks in order: base → exposure → liquidity → minimum
  - [x] 5.3 Track which adjustment was applied (for reason field)
  - [x] 5.4 Return SizingResult with all fields
  - [x] 5.5 Log sizing decision with expected vs actual format

- [x] **Task 6: Integrate with Orchestrator** (AC: 6)
  - [x] 6.1 Add position-sizer to MODULE_INIT_ORDER in orchestrator/state.js
  - [x] 6.2 Add position-sizer to MODULE_MAP in orchestrator/index.js
  - [x] 6.3 Update execution-loop.js to call calculateSize() for each entry signal
  - [x] 6.4 Pass sized positions to order-manager for execution
  - [x] 6.5 Handle sizing rejections appropriately

- [x] **Task 7: Add Configuration** (AC: 1, 7)
  - [x] 7.1 Add strategy.sizing section to config/default.js
  - [x] 7.2 Add baseSizeDollars (default: 10)
  - [x] 7.3 Add minSizeDollars (default: 1)
  - [x] 7.4 Add maxSlippagePct (default: 0.01 = 1%)
  - [x] 7.5 Add confidenceMultiplier (default: 0.5, optional feature)

- [x] **Task 8: Write Tests** (AC: all)
  - [x] 8.1 Test calculateSize() returns base size when no limits hit
  - [x] 8.2 Test calculateSize() reduces size for liquidity constraint
  - [x] 8.3 Test calculateSize() reduces size for exposure cap
  - [x] 8.4 Test calculateSize() caps at maxPositionSize
  - [x] 8.5 Test calculateSize() rejects below minimum size
  - [x] 8.6 Test SizingResult includes all required fields
  - [x] 8.7 Test logging includes expected vs actual format
  - [x] 8.8 Test config validation at init time
  - [x] 8.9 Test integration with orchestrator tick cycle
  - [x] 8.10 Test module exports standard interface

## Dev Notes

### Architecture Compliance

This story creates the position-sizer module that sits between strategy-evaluator and order-manager in the execution flow. It receives entry signals and outputs sized orders.

**From architecture.md#Inter-Module-Communication:**
> "Orchestrator pattern - modules never import each other directly. All coordination flows through orchestrator."

The position-sizer receives signals from orchestrator and returns sizing results - it never directly calls order-manager or position-manager (except via orchestrator-provided references).

**From architecture.md#Module-Interface-Contract:**
```javascript
module.exports = {
  init: async (config) => {},
  getState: () => {},
  shutdown: async () => {}
};
```

### Project Structure Notes

**Module location:** `src/modules/position-sizer/`

Create these files:
```
src/modules/position-sizer/
├── index.js          # Public interface (init, calculateSize, getState, shutdown)
├── sizing-logic.js   # Core sizing calculations
├── state.js          # Sizing statistics and metrics
├── types.js          # SizingResult, SizingError, AdjustmentReason
└── __tests__/
    ├── index.test.js        # Integration tests
    └── sizing-logic.test.js # Unit tests for sizing calculations
```

### SizingResult Type

```javascript
// src/modules/position-sizer/types.js

/**
 * Adjustment reasons for sizing decisions
 */
export const AdjustmentReason = {
  NO_ADJUSTMENT: 'no_adjustment',
  LIQUIDITY_LIMITED: 'liquidity_limited',
  EXPOSURE_CAPPED: 'exposure_capped',
  POSITION_LIMIT_CAPPED: 'position_limit_capped',
  BELOW_MINIMUM: 'below_minimum',
  REJECTED: 'rejected',
};

/**
 * Sizing result returned from calculateSize()
 */
export const SizingResult = {
  // Sizing outcome
  success: true,           // Whether a valid size was calculated
  requested_size: 0,       // Original desired size (dollars)
  actual_size: 0,          // Final size after adjustments (dollars)
  adjustment_reason: '',   // Why size was adjusted (AdjustmentReason)

  // Signal context (passed through)
  window_id: '',
  market_id: '',
  token_id: '',
  direction: '',           // 'long' or 'short'
  confidence: 0,

  // Liquidity context
  available_liquidity: 0,  // Orderbook depth available
  estimated_slippage: 0,   // Expected slippage at this size

  // Exposure context
  current_exposure: 0,     // Total exposure before this trade
  exposure_headroom: 0,    // Room left under max exposure

  // Metadata
  sized_at: '',            // ISO timestamp
};

/**
 * Position sizer error codes
 */
export const PositionSizerErrorCodes = {
  NOT_INITIALIZED: 'POSITION_SIZER_NOT_INITIALIZED',
  INVALID_SIGNAL: 'INVALID_SIGNAL',
  ORDERBOOK_FETCH_FAILED: 'ORDERBOOK_FETCH_FAILED',
  CONFIG_INVALID: 'CONFIG_INVALID',
};

export class PositionSizerError extends Error {
  constructor(code, message, context = {}) {
    super(message);
    this.name = 'PositionSizerError';
    this.code = code;
    this.context = context;
  }
}
```

### Sizing Logic Flow

```javascript
// src/modules/position-sizer/sizing-logic.js

/**
 * Calculate position size for an entry signal
 *
 * Order of checks:
 * 1. Calculate base size from config
 * 2. Apply confidence multiplier (optional)
 * 3. Cap at maxPositionSize
 * 4. Check exposure headroom
 * 5. Check orderbook liquidity
 * 6. Apply minimum size threshold
 *
 * @param {Object} signal - Entry signal from strategy-evaluator
 * @param {Object} options - Sizing options
 * @param {Object} options.config - Strategy and risk config
 * @param {Function} options.getOrderBook - Polymarket orderbook fetch function
 * @param {Function} options.getCurrentExposure - Position manager exposure function
 * @returns {SizingResult} Sizing result with all fields
 */
export async function calculateSize(signal, options) {
  const { config, getOrderBook, getCurrentExposure } = options;
  const { sizing } = config.strategy;
  const { maxPositionSize, maxExposure } = config.risk;

  let requestedSize = sizing.baseSizeDollars;
  let actualSize = requestedSize;
  let adjustmentReason = AdjustmentReason.NO_ADJUSTMENT;

  // 1. Apply confidence multiplier (optional)
  if (sizing.confidenceMultiplier && signal.confidence) {
    actualSize = requestedSize * (1 + (signal.confidence - 0.5) * sizing.confidenceMultiplier);
  }

  // 2. Cap at maxPositionSize
  if (actualSize > maxPositionSize) {
    actualSize = maxPositionSize;
    adjustmentReason = AdjustmentReason.POSITION_LIMIT_CAPPED;
  }

  // 3. Check exposure headroom
  const currentExposure = getCurrentExposure();
  const headroom = maxExposure - currentExposure;

  if (actualSize > headroom) {
    if (headroom < sizing.minSizeDollars) {
      // Not enough room for minimum trade
      return {
        success: false,
        requested_size: requestedSize,
        actual_size: 0,
        adjustment_reason: AdjustmentReason.REJECTED,
        rejection_code: 'EXPOSURE_CAP_EXCEEDED',
        current_exposure: currentExposure,
        exposure_headroom: headroom,
        // ... other fields
      };
    }
    actualSize = headroom;
    adjustmentReason = AdjustmentReason.EXPOSURE_CAPPED;
  }

  // 4. Check orderbook liquidity
  const liquidityResult = await analyzeOrderbookLiquidity(
    signal.token_id,
    signal.direction === 'long' ? 'buy' : 'sell',
    actualSize,
    getOrderBook,
    sizing.maxSlippagePct
  );

  if (liquidityResult.availableLiquidity < actualSize) {
    if (liquidityResult.availableLiquidity < sizing.minSizeDollars) {
      return {
        success: false,
        requested_size: requestedSize,
        actual_size: 0,
        adjustment_reason: AdjustmentReason.REJECTED,
        rejection_code: 'INSUFFICIENT_LIQUIDITY',
        available_liquidity: liquidityResult.availableLiquidity,
        // ... other fields
      };
    }
    actualSize = liquidityResult.availableLiquidity;
    adjustmentReason = AdjustmentReason.LIQUIDITY_LIMITED;
  }

  // 5. Minimum size check
  if (actualSize < sizing.minSizeDollars) {
    return {
      success: false,
      requested_size: requestedSize,
      actual_size: 0,
      adjustment_reason: AdjustmentReason.BELOW_MINIMUM,
      // ... other fields
    };
  }

  return {
    success: true,
    requested_size: requestedSize,
    actual_size: actualSize,
    adjustment_reason: adjustmentReason,
    window_id: signal.window_id,
    market_id: signal.market_id,
    token_id: signal.token_id,
    direction: signal.direction,
    confidence: signal.confidence,
    available_liquidity: liquidityResult.availableLiquidity,
    estimated_slippage: liquidityResult.estimatedSlippage,
    current_exposure: currentExposure,
    exposure_headroom: headroom,
    sized_at: new Date().toISOString(),
  };
}

/**
 * Analyze orderbook for available liquidity at acceptable slippage
 *
 * @param {string} tokenId - Token ID
 * @param {string} side - 'buy' or 'sell'
 * @param {number} desiredSize - Desired size in dollars
 * @param {Function} getOrderBook - Orderbook fetch function
 * @param {number} maxSlippagePct - Maximum acceptable slippage (e.g., 0.01 = 1%)
 * @returns {Object} { availableLiquidity, estimatedSlippage, depthAtPrice }
 */
async function analyzeOrderbookLiquidity(tokenId, side, desiredSize, getOrderBook, maxSlippagePct) {
  try {
    const orderbook = await getOrderBook(tokenId);

    // For buys, we look at asks (sellers); for sells, we look at bids (buyers)
    const levels = side === 'buy' ? orderbook.asks : orderbook.bids;

    if (!levels || levels.length === 0) {
      return {
        availableLiquidity: 0,
        estimatedSlippage: 1.0,
        depthAtPrice: 0,
      };
    }

    // Calculate how much we can buy/sell within acceptable slippage
    const bestPrice = parseFloat(levels[0].price);
    const slippageThreshold = side === 'buy'
      ? bestPrice * (1 + maxSlippagePct)
      : bestPrice * (1 - maxSlippagePct);

    let availableLiquidity = 0;
    let totalValue = 0;
    let lastPrice = bestPrice;

    for (const level of levels) {
      const price = parseFloat(level.price);
      const size = parseFloat(level.size);
      const value = price * size;

      // Check if this level is within acceptable slippage
      if (side === 'buy' && price > slippageThreshold) break;
      if (side === 'sell' && price < slippageThreshold) break;

      totalValue += value;
      availableLiquidity += value;
      lastPrice = price;

      if (availableLiquidity >= desiredSize) break;
    }

    // Calculate estimated slippage
    const estimatedSlippage = Math.abs(lastPrice - bestPrice) / bestPrice;

    return {
      availableLiquidity,
      estimatedSlippage,
      depthAtPrice: levels.length,
    };
  } catch (err) {
    // On orderbook fetch error, return conservative estimate
    return {
      availableLiquidity: 0,
      estimatedSlippage: 1.0,
      depthAtPrice: 0,
      error: err.message,
    };
  }
}
```

### Integration with Orchestrator

**Update `src/modules/orchestrator/state.js`:**

```javascript
// Add position-sizer to MODULE_INIT_ORDER after strategy-evaluator
export const MODULE_INIT_ORDER = [
  { name: 'persistence', module: null, configKey: 'database' },
  { name: 'polymarket', module: null, configKey: 'polymarket' },
  { name: 'spot', module: null, configKey: 'spot' },
  { name: 'position-manager', module: null, configKey: null },
  { name: 'order-manager', module: null, configKey: null },
  { name: 'strategy-evaluator', module: null, configKey: 'strategy' },
  // NEW: Add position-sizer after strategy-evaluator
  { name: 'position-sizer', module: null, configKey: 'strategy' },
];
```

**Update `src/modules/orchestrator/index.js`:**

```javascript
// Add import
import * as positionSizer from '../position-sizer/index.js';

// Add to MODULE_MAP
const MODULE_MAP = {
  // ... existing modules
  'position-sizer': positionSizer,
};
```

**Update `src/modules/orchestrator/execution-loop.js`:**

```javascript
async _onTick() {
  // ... existing code ...

  // 2. Evaluate strategy entry conditions (Story 3.2)
  let entrySignals = [];
  if (this.modules['strategy-evaluator'] && spotData) {
    // ... existing strategy evaluation code ...
  }

  // 3. Process entry signals through position sizing (Story 3.3)
  if (entrySignals.length > 0 && this.modules['position-sizer']) {
    const positionSizer = this.modules['position-sizer'];

    for (const signal of entrySignals) {
      const sizingResult = await positionSizer.calculateSize(signal, {
        getOrderBook: this.modules.polymarket?.getOrderBook,
        getCurrentExposure: this.modules['position-manager']?.getCurrentExposure,
      });

      if (sizingResult.success) {
        this.log.info('position_sized', {
          window_id: sizingResult.window_id,
          requested_size: sizingResult.requested_size,
          actual_size: sizingResult.actual_size,
          adjustment_reason: sizingResult.adjustment_reason,
        });

        // Future: Pass to order-manager for execution
        // await this.modules['order-manager'].placeOrder({...});
      } else {
        this.log.warn('position_sizing_rejected', {
          window_id: signal.window_id,
          reason: sizingResult.adjustment_reason,
          rejection_code: sizingResult.rejection_code,
        });
      }
    }
  }

  // 4. Future: Evaluate exit conditions (Stories 3.4-3.5)
  // ...
}
```

### Configuration Extension

Add to `config/default.js`:

```javascript
// Strategy configuration
strategy: {
  entry: {
    spotLagThresholdPct: 0.02,
    minConfidence: 0.6,
  },
  // NEW: Position sizing configuration
  sizing: {
    baseSizeDollars: 10,           // Base position size in dollars
    minSizeDollars: 1,             // Minimum tradeable size
    maxSlippagePct: 0.01,          // 1% max slippage
    confidenceMultiplier: 0.5,     // Size adjustment based on confidence (0 = disabled)
  },
},
```

### Structured Logging Format

Follow the architecture's structured log format:

```json
{
  "timestamp": "2026-01-31T10:15:30.123Z",
  "level": "info",
  "module": "position-sizer",
  "event": "position_sized",
  "data": {
    "window_id": "btc-15m-2026-01-31-10:15",
    "expected": {
      "base_size_dollars": 10,
      "max_position_size": 100,
      "max_exposure": 500
    },
    "actual": {
      "requested_size": 10,
      "actual_size": 8.5,
      "adjustment_reason": "liquidity_limited",
      "available_liquidity": 8.5,
      "current_exposure": 150
    }
  }
}
```

### Previous Story Intelligence

**From Story 3.2 (Strategy Entry Evaluation):**
- EntrySignal type with: window_id, market_id, direction, confidence, spot_price, market_price
- evaluateEntryConditions() returns array of signals
- Signals logged at info level with expected vs actual format
- Module integrated into execution-loop.js tick cycle

**From Story 3.1 (Orchestrator Module):**
- ExecutionLoop class with start/stop/pause/resume
- processTick() calls modules in sequence
- Modules accessed via `this.modules` object
- Error handling via onError callback

**Key patterns established:**
- Child logger via `child({ module: 'module-name' })`
- ensureInitialized() guard pattern
- Module exports standard interface
- Typed errors with codes and context

**Test count at 658 - maintain or increase**

### Existing Dependencies

**Modules used:**
- `src/modules/logger/index.js` - Structured logging via child()
- `src/clients/polymarket/index.js` - getOrderBook() for liquidity analysis
- `src/modules/position-manager/index.js` - getCurrentExposure() for limit checking
- `config/default.js` - config.risk and config.strategy sections

**Polymarket Client API:**
```javascript
// From src/clients/polymarket/index.js
async function getOrderBook(tokenId) // Returns { bids, asks } with price/size levels
async function getBestPrices(tokenId) // Returns { bid, ask, spread, midpoint }
```

**Position Manager API:**
```javascript
// From src/modules/position-manager/index.js
function getCurrentExposure() // Returns total exposure (sum of size * entry_price)
```

### Testing Patterns

Follow established vitest patterns from previous stories:

```javascript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as positionSizer from '../index.js';

// Mock logger
vi.mock('../../logger/index.js', () => ({
  child: vi.fn().mockReturnValue({
    info: vi.fn(),
    debug: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));

describe('PositionSizer', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(async () => {
    await positionSizer.shutdown();
  });

  describe('calculateSize', () => {
    it('should return base size when no limits hit', async () => {
      await positionSizer.init(mockConfig);

      const result = await positionSizer.calculateSize(mockSignal, {
        getOrderBook: vi.fn().mockResolvedValue({ asks: [{ price: 0.5, size: 100 }] }),
        getCurrentExposure: vi.fn().mockReturnValue(0),
      });

      expect(result.success).toBe(true);
      expect(result.actual_size).toBe(mockConfig.strategy.sizing.baseSizeDollars);
      expect(result.adjustment_reason).toBe('no_adjustment');
    });

    it('should reduce size for liquidity constraint', async () => {
      await positionSizer.init(mockConfig);

      const result = await positionSizer.calculateSize(mockSignal, {
        getOrderBook: vi.fn().mockResolvedValue({ asks: [{ price: 0.5, size: 5 }] }), // Only $2.5 available
        getCurrentExposure: vi.fn().mockReturnValue(0),
      });

      expect(result.success).toBe(true);
      expect(result.actual_size).toBeLessThan(mockConfig.strategy.sizing.baseSizeDollars);
      expect(result.adjustment_reason).toBe('liquidity_limited');
    });

    it('should reject when exposure cap exceeded', async () => {
      await positionSizer.init(mockConfig);

      const result = await positionSizer.calculateSize(mockSignal, {
        getOrderBook: vi.fn().mockResolvedValue({ asks: [{ price: 0.5, size: 100 }] }),
        getCurrentExposure: vi.fn().mockReturnValue(500), // At max exposure
      });

      expect(result.success).toBe(false);
      expect(result.adjustment_reason).toBe('rejected');
      expect(result.rejection_code).toBe('EXPOSURE_CAP_EXCEEDED');
    });
  });
});
```

### NFR Compliance

- **FR4** (Size positions based on config + liquidity): Core purpose of this story
- **FR5** (Respect position limits and exposure caps): Enforced in sizing logic
- **FR35** (Configure strategy parameters without code changes): All sizing params in config
- **FR36** (Configure risk limits): Uses config.risk.maxPositionSize and maxExposure
- **NFR5** (Market data processing keeps pace): Sizing completes within tick interval
- **NFR9** (100% of trade events produce structured log): All sizing decisions logged

### Signal Flow After This Story

```
Tick → Spot Price → Strategy Evaluator → Entry Signal
                                              ↓
                                    Position Sizer (this story)
                                              ↓
                                    SizingResult { actual_size, ... }
                                              ↓
                                    Order Manager → CLOB (future)
```

### Critical Implementation Notes

1. **Orderbook Analysis**: The getOrderBook() call is async and may fail. Handle gracefully with conservative fallback (reject trade if orderbook unavailable).

2. **Exposure Calculation**: getCurrentExposure() returns total open position value. This must include both realized positions AND pending orders to avoid over-exposure.

3. **Slippage Calculation**: Walk the orderbook levels to estimate actual fill price. Don't assume best price for large orders.

4. **Minimum Size**: The minimum tradeable size on Polymarket may vary. Use config.strategy.sizing.minSizeDollars to reject tiny trades.

5. **Confidence Multiplier**: This is an optional feature. If confidenceMultiplier is 0 or not set, skip this adjustment.

### References

- [Source: architecture.md#Inter-Module-Communication] - Orchestrator pattern
- [Source: architecture.md#Module-Interface-Contract] - init, getState, shutdown
- [Source: architecture.md#Structured-Log-Format] - JSON log schema
- [Source: architecture.md#Naming-Patterns] - snake_case for log fields
- [Source: epics.md#Story-3.3] - Story requirements and acceptance criteria
- [Source: prd.md#FR4] - Size positions based on config and liquidity
- [Source: prd.md#FR5] - Respect position limits and exposure caps
- [Source: 3-2-strategy-entry-evaluation.md] - Previous story patterns and signal type
- [Source: 3-1-orchestrator-module-execution-loop.md] - Orchestrator tick integration
- [Source: src/modules/position-manager/index.js:137-141] - getCurrentExposure() API
- [Source: src/clients/polymarket/index.js:135-138] - getOrderBook() API
- [Source: config/default.js:27-32] - Risk configuration section

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

None - implementation completed without errors.

### Completion Notes List

- ✅ Created position-sizer module with standard interface (init, getState, shutdown, calculateSize)
- ✅ Implemented types.js with AdjustmentReason, RejectionCode, PositionSizerError, and factory functions
- ✅ Implemented state.js for tracking sizing statistics (sizing count, success/rejection counts, adjustment counts)
- ✅ Implemented sizing-logic.js with calculateSize(), analyzeOrderbookLiquidity(), calculateBaseSize(), checkExposureLimits()
- ✅ Integrated with orchestrator (MODULE_INIT_ORDER, MODULE_MAP, execution-loop.js)
- ✅ Added strategy.sizing configuration to config/default.js
- ✅ Created comprehensive test suite with 73 tests (45 integration tests, 28 unit tests)
- ✅ All 731 tests pass (up from 658, adding 73 new tests)
- ✅ Follows established patterns: child logger, ensureInitialized guard, typed errors with codes
- ✅ Implements expected vs actual logging format for diagnostics
- ✅ Handles edge cases: orderbook fetch failure, missing getCurrentExposure, empty orderbooks

### File List

**New Files:**
- src/modules/position-sizer/index.js
- src/modules/position-sizer/types.js
- src/modules/position-sizer/state.js
- src/modules/position-sizer/sizing-logic.js
- src/modules/position-sizer/__tests__/index.test.js
- src/modules/position-sizer/__tests__/sizing-logic.test.js

**Modified Files:**
- src/modules/orchestrator/state.js (added position-sizer to MODULE_INIT_ORDER)
- src/modules/orchestrator/index.js (added import and MODULE_MAP entry)
- src/modules/orchestrator/execution-loop.js (added position sizing in tick cycle)
- config/default.js (added strategy.sizing section)
- _bmad-output/implementation-artifacts/sprint-status.yaml (updated story status)

## Change Log

- 2026-01-31: Implemented story 3-3-position-sizing-liquidity - Created position-sizer module with full sizing logic, orderbook liquidity analysis, exposure checking, and orchestrator integration. Added 73 new tests (total: 731 tests passing).
