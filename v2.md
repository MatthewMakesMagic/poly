# V2 Strategy Framework: Position Path Analysis & Fair Value Validation

---

## CRITICAL FINDING: Lag Tracker Not Gating Signals (2026-02-02)

### The Problem

**The lag-tracker component is running but NOT actually gating trade signals.**

Despite having a `lag-based` strategy configured with:
```json
{
  "name": "lag-based",
  "components": {
    "priceSource": "src-rtds-client-v1",
    "probability": "prob-window-timing-model-v1",
    "analysis": ["anal-lag-tracker-v1"]
  },
  "pipeline": {
    "order": ["priceSource", "probability", "analysis"],
    "signalAggregation": "lag_signal"
  }
}
```

The orchestrator (`src/modules/orchestrator/index.js` lines 617-678) **ignores the lag-tracker output** and always uses this flow:

1. Calculate probability from Black-Scholes window-timing-model
2. Compare `modelProbability` to `marketPrice`
3. If `edge >= 10%`, generate signal

**The `signalAggregation: 'lag_signal'` setting is defined in config but NOT implemented in the orchestrator.**

### What This Means

| Strategy | What You Think It Does | What It Actually Does |
|----------|----------------------|----------------------|
| `probability-model` | Pure B-S edge | Pure B-S edge ✓ |
| `lag-based` | B-S + lag confirmation | Pure B-S edge (lag runs but unused) |
| `oracle-edge` | Staleness fade | Pure B-S edge (uses oracle-edge-signal but falls through to edge calc) |
| `hybrid` | Weighted 30/40/30 | Pure B-S edge (weights defined but not implemented) |

**Your current live system runs ONLY Black-Scholes probability edge, regardless of which strategy is selected.**

### The Lag Tracker IS Running

The lag-tracker (`src/modules/lag-tracker/tracker.js`) correctly:
- Buffers Binance spot prices
- Buffers Chainlink oracle prices
- Calculates cross-correlation at various τ values
- Identifies optimal lag (τ*)
- Detects when spot moves while oracle is stale

But `getLagSignal()` output is never checked before signal generation.

### Required Fix

The orchestrator needs to implement signal aggregation modes:

```javascript
// CURRENT (broken):
if (edgeUp >= minEdgeThreshold) {
  windowSignal = { ... };  // Always fires on edge alone
}

// NEEDED for lag_signal mode:
if (pipeline.signalAggregation === 'lag_signal') {
  const lagSignal = lagTracker.getLagSignal(symbol);
  if (!lagSignal.has_signal) continue;  // Gate on lag confirmation
  if (edgeUp >= minEdgeThreshold) {
    windowSignal = { ..., lag_confirmation: lagSignal };
  }
}
```

### Implications for Probability Model Assessment

The 15-minute lookback for volatility calculation IS being used, but:

1. **Lookback matches cycle** - 15min lookback for 15min windows is circular reasoning
2. **Sparse data** - May only have 3-15 oracle updates in 15 minutes
3. **No regime detection** - Doesn't distinguish trending vs mean-reverting
4. **Volatility surprise** - Flags but doesn't pause when vol spikes 1.5x

### Action Items

- [ ] Implement `signalAggregation` handling in orchestrator
- [ ] Add lag confirmation to signal generation for `lag-based` strategy
- [ ] Implement weighted averaging for `hybrid` strategy
- [ ] Consider longer volatility lookback (6h baseline already available)
- [ ] Add calibration tracking to validate probability buckets

---

## Philosophy

### The Core Problem

We're trading 15-minute binary options on Polymarket, but our understanding of two critical components is incomplete:

1. **Fair Value Calculation**: Our current heuristic (`fairProb = 0.5 + (spotDelta / strike) * scaleFactor`) ignores time-to-expiry, which is fundamental to option pricing. A binary option with spot 0.1% above strike should have very different probabilities at T-10min vs T-10sec.

2. **Exit Timing**: We default to hold-to-expiry, but binary options that hit 95¢ or 99¢ might be better closed early. We have no data on optimal exit points.

### The Honest Assessment

**We don't know if our lag detection captures real alpha or noise.**

The market may already price time correctly. Our "lag" signal (fair value diverging from market) might be:
- A real opportunity (market is slow to adjust)
- Noise (our fair value is wrong)
- Already arbed away by the time we execute

### What We're Testing

**Hypothesis 1: Market Efficiency by Time**
- Does the Polymarket price converge toward binary outcomes as expiry approaches?
- At T-30sec, is market price more predictive than at T-5min?
- Does variance decrease as time decreases (as it should for proper binary option pricing)?

**Hypothesis 2: Time-Adjusted Fair Value**
- Does incorporating time-to-expiry improve our fair value accuracy?
- Proper formula: `P(spot > strike) = Φ((ln(spot/strike)) / (σ√τ))`
- Simplified proxy: Scale confidence by `1/√(time_remaining_sec)`

**Hypothesis 3: Exit Optimization**
- How often do winning positions hit 95¢/99¢ before expiry?
- What's the P&L difference between hold-to-expiry vs exit-at-peak?
- Is there a trailing stop configuration that improves returns?

---

## Data Requirements

### Already Captured (in `ticks` table)
- `spot_price` - Binance spot price
- `price_to_beat` - Window strike price
- `up_mid` - Market probability (what Polymarket is pricing)
- `time_remaining_sec` - Time to window expiry
- `spot_delta_pct` - Spot vs strike as percentage

### Now Capturing (new services)
- **OracleOverseer**: Lag events with bid/ask price changes, execution latency
- **Resolution Service**: Final 60-second Binance/Chainlink/Market snapshots
- **Position Path Tracker**: Complete price path from entry to expiry

---

## Validation Plan

### Step 1: Run Fair Value Validation Script

Query production database with `scripts/validate_fair_value.mjs`:

```bash
DATABASE_URL=<railway_url> node scripts/validate_fair_value.mjs
```

Key questions answered:
- Does market probability correlate with spot position relative to strike?
- Does this correlation strengthen as time decreases?
- How accurate is our naive fair value vs market vs actual outcome?

### Step 2: Collect Position Path Data

Enable position path tracking for all paper trades for 48-72 hours.

Key questions answered:
- What % of positions hit 95¢? 99¢?
- What was the peak P&L vs final P&L for each position?
- At what time remaining did positions typically hit peak?

### Step 3: Analyze Exit Scenarios

Compare P&L under different exit strategies:
- Hold to expiry (current default)
- Exit at 95¢
- Exit at 99¢
- Exit at peak (theoretical maximum)
- Trailing stop (10% from peak)

---

## Strategy Variants to Test

### Lag Threshold Variants
Test different minimum lag magnitudes to signal entry:
- `SpotLag_3pct` - Enter on 3% lag (current)
- `SpotLag_5pct` - Enter on 5% lag (fewer signals, higher confidence)
- `SpotLag_7pct` - Enter on 7% lag (even fewer, even higher confidence)

**Question**: Does larger lag = better win rate?

### Time-Based Entry Variants
Test entry timing relative to expiry:
- `SpotLag_T300` - Only enter with >5min remaining
- `SpotLag_T120` - Only enter with >2min remaining
- `SpotLag_T60` - Only enter in final minute

**Question**: Is alpha concentrated in any time window?

### Exit Strategy Variants
Test different exit approaches (all starting from same entry):
- `SpotLag_Hold` - Hold to expiry
- `SpotLag_TP95` - Exit at 95¢
- `SpotLag_TP99` - Exit at 99¢
- `SpotLag_Trail10` - Trailing stop 10% from peak

**Question**: Which exit strategy maximizes realized P&L?

### Chainlink Confirmation
Test requiring oracle agreement:
- `SpotLag_CLConfirm` - Only trade when Chainlink agrees with Binance on direction

**Question**: Does oracle confirmation improve win rate enough to offset reduced signal frequency?

---

## Metrics to Track

### Per Strategy
- Signal frequency (signals per hour)
- Fill rate (live trades only)
- Slippage (paper price vs live fill)
- Win rate
- Average P&L per trade
- Sharpe ratio

### Per Position (via Path Tracker)
- Entry price, exit price
- Peak price during position
- Time to peak (seconds before expiry)
- Whether hit 95¢/99¢
- Max drawdown
- P&L under each exit scenario

### Market Structure
- Spread at entry
- Book depth at entry
- Volatility regime
- Chainlink staleness

---

## Success Criteria

After 1 week of data collection:

1. **Fair Value Model**: Identify whether time-adjusted fair value outperforms naive model
2. **Exit Strategy**: Determine if any exit strategy beats hold-to-expiry by >5%
3. **Entry Timing**: Identify optimal time-to-expiry window for entries
4. **Lag Threshold**: Determine minimum lag magnitude that reliably captures alpha

---

## Risk Acknowledgments

### Known Unknowns
- Market may already be efficient and our "edge" is noise
- Fair value model may be fundamentally flawed
- Execution reality may destroy theoretical edge

### Mitigation
- All strategies run at $1 positions until validated
- Track paper vs live divergence to quantify execution cost
- Build statistical significance requirements (n>100) before scaling

---

## Implementation Status

| Component | Status | Notes |
|-----------|--------|-------|
| OracleOverseer | ✅ Complete | Tracks lag events + latency |
| Resolution Service | ✅ Complete | Captures final-minute data |
| Position Path Tracker | ✅ Complete | Tracks entry-to-exit paths |
| Fair Value Validation | ✅ Script ready | Needs DATABASE_URL to run |
| Strategy Variants | ⏳ Pending | After validation complete |
| Live Deployment | ⏳ Pending | After variants created |

---

## Next Steps

1. **Immediate**: Run fair value validation script against production data
2. **24h**: Integrate position path tracker into paper trading
3. **48h**: Review path data, determine exit strategy
4. **72h**: Create strategy variants based on findings
5. **1 week**: Deploy variants live at $1, collect execution data
6. **2 weeks**: Analyze results, determine scaling approach
